using ITX.Application.Interfaces;
using ITX.Application.ViewModels;
using ITX.Domain.Entities;
using ITX.Domain.Entities.LogManagement;
using ITX.Domain.Entities.FormManagement;
using ITX.Domain.Entities.Identity;
using ITX.Domain.Entities.Predefined;
// using ITX.Domain
using ITX.Domain.Entities.Test;
using ITX.Domain.Shared.Enums;
using Microsoft.AspNetCore.Identity;
using Microsoft.AspNetCore.Identity.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using System.Reflection;

namespace ITX.Persistance.Database.Context
{
    public class ITManagementDbContext : IdentityDbContext<
        User,
        Role,
        Guid,
        UserClaim,
        UserRole,
        IdentityUserLogin<Guid>,
        RoleClaim,
        IdentityUserToken<Guid>
       >
    {
        private readonly ICurrentUserService _currentUserService;
        private readonly IDateTime _dateTime;
        protected string _connectionString { get; set; }

        public ITManagementDbContext(DbContextOptions<ITManagementDbContext> options, ICurrentUserService currentUserService, IDateTime dateTime)
      : base(options)
        {
            _currentUserService = currentUserService;
            _dateTime = dateTime;
        }

        // FormYonetim
        public virtual DbSet<FormTanim> FormTanims { get; set; }
        public virtual DbSet<ValueText> ValueTexts { get; set; }
        public virtual DbSet<ValueNumber> ValueNumbers { get; set; }
        public virtual DbSet<DegerTarih> DegerTarihs { get; set; }
        public virtual DbSet<FormAlan> FormAlans { get; set; }
        public virtual DbSet<FormDeger> FormDegers { get; set; }
        public virtual DbSet<FormTarihce> FormTarihces { get; set; }
        public virtual DbSet<EnumVeri> EnumVeris { get; set; }

        // Predefined
        public virtual DbSet<Menu> Menus { get; set; }
        public virtual DbSet<MenuRole> MenuRoles { get; set; }
        public virtual DbSet<CurrencyDefinition> CurrencyDefinitions { get; set; }
        public virtual DbSet<City> Citys { get; set; }
        public virtual DbSet<Country> Countrys { get; set; }
        public virtual DbSet<District> Districts { get; set; }
        public virtual DbSet<AppSetting> AppSettings { get; set; }
        public virtual DbSet<Announce> Announces { get; set; }
        public virtual DbSet<AuditLog> AuditLogs { get; set; }
        public virtual DbSet<RequestLog> RequestLogs { get; set; }
        public virtual DbSet<KeyValuePairModel> KeyValuePairModel { get; set; }
        public virtual DbSet<ClaimType> ClaimTypes { get; set; }

        /* <auto-generated (for-script)/> */
		public virtual DbSet<Lesson> Lessons { get; set; }

		public virtual DbSet<StudentLesson> StudentLessons { get; set; }

		public virtual DbSet<Student> Students { get; set; }

		public virtual DbSet<Scenario> Scenarios { get; set; }


        protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
        {
            if (_connectionString != null)
                optionsBuilder.UseNpgsql(_connectionString);

            if (InsideLINQPad) optionsBuilder.EnableSensitiveDataLogging(true);
        }

        internal bool InsideLINQPad => AppDomain.CurrentDomain.FriendlyName.StartsWith("LINQPad");
        // ****************************************************************************************

        public override async Task<int> SaveChangesAsync(CancellationToken cancellationToken = new CancellationToken())
        {
            // convert UserId to Guid otherwise, Guid.Empty
            _ = Guid.TryParse(_currentUserService.GetUserId(), out Guid userId);
            if (userId == Guid.Empty)
            {
                userId = Application.ApplicationData.TempUserId;
            }
            // AuditLog step 1
            List<AuditLogEntry> auditEntries = new List<AuditLogEntry>();
            if (userId != Guid.Empty)
            {
                OnBeforeSaveChanges(userId);
            }

            foreach (var entry in ChangeTracker.Entries<BaseEntity<long>>())
            {
                switch (entry.State)
                {
                    case EntityState.Added:
                        entry.Entity.CreatedBy = userId;
                        entry.Entity.CreatedAt = _dateTime.Now;
                        entry.Entity.UpdatedBy = userId;
                        entry.Entity.UpdatedAt = _dateTime.Now;
                        entry.Entity.IsActive = true;
                        entry.Entity.IsDeleted = false;

                        break;

                    case EntityState.Modified:
                        entry.Entity.UpdatedBy = userId;
                        entry.Entity.UpdatedAt = _dateTime.Now;
                        break;
                }
            }

            var result = await base.SaveChangesAsync(cancellationToken);

            // AuditLog step 2
            if (userId != Guid.Empty)
            {
                await OnAfterSaveChanges(auditEntries);
            }

            return result;
        }

        // AuditLog step 1
        private List<AuditLogEntry> OnBeforeSaveChanges(Guid userId)
        {
            ChangeTracker.DetectChanges();
            List<AuditLogEntry> auditEntries = new List<AuditLogEntry>();
            foreach (var entry in ChangeTracker.Entries())
            {
                // DO NOT LOG!!!: Exemptions: AuditLog, BulkReading, JobOrder... 
                if (entry.Entity is AuditLog ||
                    entry.State == EntityState.Detached || entry.State == EntityState.Unchanged)
                {
                    continue;
                }

                var auditEntry = new AuditLogEntry(entry)
                {
                    TableName = entry.Entity.GetType().Name,
                    UserId = userId
                };

                auditEntries.Add(auditEntry);
                foreach (var property in entry.Properties)
                {
                    if (property.IsTemporary)
                    {
                        auditEntry.TemporaryProperties.Add(property);
                        continue;
                    }

                    string propertyName = property.Metadata.Name;
                    if (property.Metadata.IsPrimaryKey())
                    {
                        auditEntry.KeyValues[propertyName] = property.CurrentValue;
                        continue;
                    }

                    // Ignore auditable properties
                    string[] nonAuditableProperties =
                        { "CreatedAt", "CreatedBy", "UpdatedAt", "UpdatedBy", "PasswordHash", "SecurityStamp" };
                    if (nonAuditableProperties.Contains(propertyName))
                    {
                        continue;
                    }

                    switch (entry.State)
                    {
                        case EntityState.Added:
                            auditEntry.AuditLogTypeCodeId = EnmAuditLogTypeCode.Create;
                            auditEntry.NewValues[propertyName] = property.CurrentValue;
                            break;

                        case EntityState.Deleted:
                            auditEntry.AuditLogTypeCodeId = EnmAuditLogTypeCode.Delete;
                            auditEntry.OldValues[propertyName] = property.OriginalValue;
                            break;

                        case EntityState.Modified:
                            if (property.IsModified && property.OriginalValue?.Equals(property.CurrentValue) == false)
                            {
                                auditEntry.ChangedColumns.Add(propertyName);
                                auditEntry.AuditLogTypeCodeId = EnmAuditLogTypeCode.Update;
                                auditEntry.OldValues[propertyName] = property.OriginalValue;
                                auditEntry.NewValues[propertyName] = property.CurrentValue;
                            }
                            break;
                    }
                }
            }

            foreach (var auditEntry in auditEntries.Where(_ => !_.HasTemporaryProperties))
            {
                AuditLogs.Add(auditEntry.ToAudit());
            }
            return auditEntries.Where(_ => _.HasTemporaryProperties).ToList();
        }

        // AuditLog step 2
        private Task OnAfterSaveChanges(List<AuditLogEntry> auditLogEntries)
        {
            if (auditLogEntries == null || auditLogEntries.Count == 0)
                return Task.CompletedTask;

            foreach (var auditEntry in auditLogEntries)
            {
                foreach (var prop in auditEntry.TemporaryProperties)
                {
                    if (prop.Metadata.IsPrimaryKey())
                    {
                        auditEntry.KeyValues[prop.Metadata.Name] = prop.CurrentValue;
                    }
                    else
                    {
                        auditEntry.NewValues[prop.Metadata.Name] = prop.CurrentValue;
                    }
                }
                AuditLogs.Add(auditEntry.ToAudit());
            }
            return SaveChangesAsync();
        }

        protected override void OnModelCreating(ModelBuilder builder)
        {
            InitialData.SeedUsers(builder);
            InitialData.SeedRoles(builder);
            InitialData.SeedUserRoles(builder);
            base.OnModelCreating(builder);
            InitialData.SeedUserClaims(builder);
            InitialData.SeedRoleClaims(builder);

            // Entity configurations are applied here: ../Data/Configurations
            builder.ApplyConfigurationsFromAssembly(Assembly.GetExecutingAssembly());

            foreach (var relationship in builder.Model.GetEntityTypes().SelectMany(e => e.GetForeignKeys()))
            {
                relationship.DeleteBehavior = DeleteBehavior.Restrict;
            }

            builder.Entity<User>()
                .HasMany(e => e.UserRoles)
                .WithOne(e => e.User)
                .HasForeignKey(e => e.UserId)
                .IsRequired()
                .OnDelete(DeleteBehavior.Cascade);

            builder.Entity<User>()
                .HasMany(e => e.UserClaims)
                .WithOne(e => e.User)
                .HasForeignKey(e => e.UserId)
                .IsRequired()
                .OnDelete(DeleteBehavior.Cascade);

            builder.Entity<Role>()
                .HasMany(e => e.UserRoles)
                .WithOne(e => e.Role)
                .HasForeignKey(e => e.RoleId)
                .IsRequired()
                .OnDelete(DeleteBehavior.Cascade);

            builder.Entity<Role>()
               .HasMany(e => e.RoleClaims)
               .WithOne(e => e.Role)
               .HasForeignKey(e => e.RoleId)
               .IsRequired()
               .OnDelete(DeleteBehavior.Cascade);

            builder.Entity<MenuRole>()
                .HasOne(mr => mr.Menu)
                .WithMany(m => m.MenuRoles)
                .HasForeignKey(mr => mr.MenuId)
                .IsRequired()
                .OnDelete(DeleteBehavior.Cascade);

            builder.Entity<KeyValuePairModel>(e => { e.HasNoKey(); });
            builder.Entity<CurrencyDefinition>().Property(b => b.Id).HasIdentityOptions(startValue: 250);
            builder.Entity<Country>().Property(b => b.Id).HasIdentityOptions(startValue: 250);
            builder.Entity<City>().Property(b => b.Id).HasIdentityOptions(startValue: 85);
        }
    }
}
